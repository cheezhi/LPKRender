/**
 * LPKRender (LPKR) v1.0.0
 * 极简的 Live2D LPK 模型渲染器
 * 
 * 项目地址：https://github.com/cheezhi/LPKRender
 * 
 * 使用方法：
 * <script src="lpkr.min.js"></script>
 * <script>
 *   LPKRender.init({
 *     lpkFile: '/model.lpk'  // LPK 模型文件路径
 *   });
 * </script>
 * 
 * 
 * @license MIT
 */
(function(global) {
  'use strict';

  // 加载外部脚本
  function loadScript(src) {
    return new Promise((resolve, reject) => {
      if (document.querySelector(`script[src="${src}"]`)) {
        resolve();
        return;
      }
      const script = document.createElement('script');
      script.src = src;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }

  // MD5 实现
  function md5String(string) {
    function rotateLeft(lValue, iShiftBits) {
      return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));
    }
    function addUnsigned(lX, lY) {
      var lX4, lY4, lX8, lY8, lResult;
      lX8 = (lX & 0x80000000);
      lY8 = (lY & 0x80000000);
      lX4 = (lX & 0x40000000);
      lY4 = (lY & 0x40000000);
      lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);
      if (lX4 & lY4) return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
      if (lX4 | lY4) {
        if (lResult & 0x40000000) return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
        else return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
      } else {
        return (lResult ^ lX8 ^ lY8);
      }
    }
    function f(x, y, z) { return (x & y) | ((~x) & z); }
    function g(x, y, z) { return (x & z) | (y & (~z)); }
    function h(x, y, z) { return (x ^ y ^ z); }
    function i(x, y, z) { return (y ^ (x | (~z))); }
    function ff(a, b, c, d, x, s, ac) {
      a = addUnsigned(a, addUnsigned(addUnsigned(f(b, c, d), x), ac));
      return addUnsigned(rotateLeft(a, s), b);
    }
    function gg(a, b, c, d, x, s, ac) {
      a = addUnsigned(a, addUnsigned(addUnsigned(g(b, c, d), x), ac));
      return addUnsigned(rotateLeft(a, s), b);
    }
    function hh(a, b, c, d, x, s, ac) {
      a = addUnsigned(a, addUnsigned(addUnsigned(h(b, c, d), x), ac));
      return addUnsigned(rotateLeft(a, s), b);
    }
    function ii(a, b, c, d, x, s, ac) {
      a = addUnsigned(a, addUnsigned(addUnsigned(i(b, c, d), x), ac));
      return addUnsigned(rotateLeft(a, s), b);
    }
    function convertToWordArray(string) {
      var lWordCount;
      var lMessageLength = string.length;
      var lNumberOfWordsTemp1 = lMessageLength + 8;
      var lNumberOfWordsTemp2 = (lNumberOfWordsTemp1 - (lNumberOfWordsTemp1 % 64)) / 64;
      var lNumberOfWords = (lNumberOfWordsTemp2 + 1) * 16;
      var lWordArray = new Array(lNumberOfWords - 1);
      var lBytePosition = 0;
      var lByteCount = 0;
      while (lByteCount < lMessageLength) {
        lWordCount = (lByteCount - (lByteCount % 4)) / 4;
        lBytePosition = (lByteCount % 4) * 8;
        lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount) << lBytePosition));
        lByteCount++;
      }
      lWordCount = (lByteCount - (lByteCount % 4)) / 4;
      lBytePosition = (lByteCount % 4) * 8;
      lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 << lBytePosition);
      lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
      lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
      return lWordArray;
    }
    function wordToHex(lValue) {
      var wordToHexValue = "", wordToHexValueTemp = "", lByte, lCount;
      for (lCount = 0; lCount <= 3; lCount++) {
        lByte = (lValue >>> (lCount * 8)) & 255;
        wordToHexValueTemp = "0" + lByte.toString(16);
        wordToHexValue = wordToHexValue + wordToHexValueTemp.substr(wordToHexValueTemp.length - 2, 2);
      }
      return wordToHexValue;
    }
    function utf8Encode(string) {
      string = string.replace(/\r\n/g, "\n");
      var utftext = "";
      for (var n = 0; n < string.length; n++) {
        var c = string.charCodeAt(n);
        if (c < 128) {
          utftext += String.fromCharCode(c);
        } else if ((c > 127) && (c < 2048)) {
          utftext += String.fromCharCode((c >> 6) | 192);
          utftext += String.fromCharCode((c & 63) | 128);
        } else {
          utftext += String.fromCharCode((c >> 12) | 224);
          utftext += String.fromCharCode(((c >> 6) & 63) | 128);
          utftext += String.fromCharCode((c & 63) | 128);
        }
      }
      return utftext;
    }
    var x = [];
    var k, AA, BB, CC, DD, a, b, c, d;
    var S11 = 7, S12 = 12, S13 = 17, S14 = 22;
    var S21 = 5, S22 = 9, S23 = 14, S24 = 20;
    var S31 = 4, S32 = 11, S33 = 16, S34 = 23;
    var S41 = 6, S42 = 10, S43 = 15, S44 = 21;
    string = utf8Encode(string);
    x = convertToWordArray(string);
    a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;
    for (k = 0; k < x.length; k += 16) {
      AA = a; BB = b; CC = c; DD = d;
      a = ff(a, b, c, d, x[k + 0], S11, 0xD76AA478);
      d = ff(d, a, b, c, x[k + 1], S12, 0xE8C7B756);
      c = ff(c, d, a, b, x[k + 2], S13, 0x242070DB);
      b = ff(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);
      a = ff(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);
      d = ff(d, a, b, c, x[k + 5], S12, 0x4787C62A);
      c = ff(c, d, a, b, x[k + 6], S13, 0xA8304613);
      b = ff(b, c, d, a, x[k + 7], S14, 0xFD469501);
      a = ff(a, b, c, d, x[k + 8], S11, 0x698098D8);
      d = ff(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);
      c = ff(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);
      b = ff(b, c, d, a, x[k + 11], S14, 0x895CD7BE);
      a = ff(a, b, c, d, x[k + 12], S11, 0x6B901122);
      d = ff(d, a, b, c, x[k + 13], S12, 0xFD987193);
      c = ff(c, d, a, b, x[k + 14], S13, 0xA679438E);
      b = ff(b, c, d, a, x[k + 15], S14, 0x49B40821);
      a = gg(a, b, c, d, x[k + 1], S21, 0xF61E2562);
      d = gg(d, a, b, c, x[k + 6], S22, 0xC040B340);
      c = gg(c, d, a, b, x[k + 11], S23, 0x265E5A51);
      b = gg(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA);
      a = gg(a, b, c, d, x[k + 5], S21, 0xD62F105D);
      d = gg(d, a, b, c, x[k + 10], S22, 0x2441453);
      c = gg(c, d, a, b, x[k + 15], S23, 0xD8A1E681);
      b = gg(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);
      a = gg(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);
      d = gg(d, a, b, c, x[k + 14], S22, 0xC33707D6);
      c = gg(c, d, a, b, x[k + 3], S23, 0xF4D50D87);
      b = gg(b, c, d, a, x[k + 8], S24, 0x455A14ED);
      a = gg(a, b, c, d, x[k + 13], S21, 0xA9E3E905);
      d = gg(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);
      c = gg(c, d, a, b, x[k + 7], S23, 0x676F02D9);
      b = gg(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);
      a = hh(a, b, c, d, x[k + 5], S31, 0xFFFA3942);
      d = hh(d, a, b, c, x[k + 8], S32, 0x8771F681);
      c = hh(c, d, a, b, x[k + 11], S33, 0x6D9D6122);
      b = hh(b, c, d, a, x[k + 14], S34, 0xFDE5380C);
      a = hh(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);
      d = hh(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);
      c = hh(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);
      b = hh(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);
      a = hh(a, b, c, d, x[k + 13], S31, 0x289B7EC6);
      d = hh(d, a, b, c, x[k + 0], S32, 0xEAA127FA);
      c = hh(c, d, a, b, x[k + 3], S33, 0xD4EF3085);
      b = hh(b, c, d, a, x[k + 6], S34, 0x4881D05);
      a = hh(a, b, c, d, x[k + 9], S31, 0xD9D4D039);
      d = hh(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);
      c = hh(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);
      b = hh(b, c, d, a, x[k + 2], S34, 0xC4AC5665);
      a = ii(a, b, c, d, x[k + 0], S41, 0xF4292244);
      d = ii(d, a, b, c, x[k + 7], S42, 0x432AFF97);
      c = ii(c, d, a, b, x[k + 14], S43, 0xAB9423A7);
      b = ii(b, c, d, a, x[k + 5], S44, 0xFC93A039);
      a = ii(a, b, c, d, x[k + 12], S41, 0x655B59C3);
      d = ii(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);
      c = ii(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);
      b = ii(b, c, d, a, x[k + 1], S44, 0x85845DD1);
      a = ii(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);
      d = ii(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);
      c = ii(c, d, a, b, x[k + 6], S43, 0xA3014314);
      b = ii(b, c, d, a, x[k + 13], S44, 0x4E0811A1);
      a = ii(a, b, c, d, x[k + 4], S41, 0xF7537E82);
      d = ii(d, a, b, c, x[k + 11], S42, 0xBD3AF235);
      c = ii(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);
      b = ii(b, c, d, a, x[k + 9], S44, 0xEB86D391);
      a = addUnsigned(a, AA);
      b = addUnsigned(b, BB);
      c = addUnsigned(c, CC);
      d = addUnsigned(d, DD);
    }
    var tempValue = wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d);
    return tempValue.toLowerCase();
  }

  function genkey(s) {
    let ret = 0n;
    for (let i = 0; i < s.length; i++) {
      ret = (ret * 31n + BigInt(s.charCodeAt(i))) & 0xffffffffn;
    }
    if (ret & 0x80000000n) {
      ret = ret | 0xffffffff00000000n;
    }
    return ret;
  }

  function decrypt(key, data) {
    const ret = [];
    let keyBigInt = typeof key === 'bigint' ? key : BigInt(key);
    for (let i = 0; i < data.length; i += 1024) {
      const slice = data.subarray(i, i + 1024);
      let tmpkey = keyBigInt;
      for (let j = 0; j < slice.length; j++) {
        const mul = 214013n * tmpkey;
        const sum = 2531011n + mul;
        const shifted = sum >> 16n;
        tmpkey = (65535n & shifted) & 0xffffffffn;
        ret.push(Number(tmpkey & 0xffn) ^ slice[j]);
      }
    }
    return new Uint8Array(ret);
  }

  function isEncryptedFile(s) {
    const matchRule = /^[0-9a-f]{32}\.bin3?$/;
    return matchRule.test(s);
  }

  function findEncryptedFile(s) {
    const matchRule = /[0-9a-f]{32}\.bin3?/g;
    const matches = s.match(matchRule);
    return matches ? matches[0] : null;
  }

  function* travelsDict(dic, prefix) {
    prefix = prefix || '';
    for (const k in dic) {
      const fullKey = prefix ? `${prefix}_${k}` : k;
      if (typeof dic[k] === 'object' && dic[k] !== null && !Array.isArray(dic[k])) {
        yield* travelsDict(dic[k], fullKey);
      } else if (Array.isArray(dic[k])) {
        yield* travelsList(dic[k], fullKey);
      } else {
        yield [fullKey, dic[k]];
      }
    }
  }

  function* travelsList(vals, prefix) {
    prefix = prefix || '';
    for (let i = 0; i < vals.length; i++) {
      const fullKey = prefix ? `${prefix}_${i}` : String(i);
      if (typeof vals[i] === 'object' && vals[i] !== null && !Array.isArray(vals[i])) {
        yield* travelsDict(vals[i], fullKey);
      } else if (Array.isArray(vals[i])) {
        yield* travelsList(vals[i], fullKey);
      } else {
        yield [fullKey, vals[i]];
      }
    }
  }

  function guessType(data) {
    if (data.length > 3 && data[0] === 0x89 && data[1] === 0x50 && data[2] === 0x4E && data[3] === 0x47) {
      return '.png';
    }
    if (data.length > 3 && data[0] === 0xFF && data[1] === 0xD8 && data[2] === 0xFF) {
      return '.jpg';
    }
    if (data.length > 11 && data[0] === 0x52 && data[1] === 0x49 && data[2] === 0x46 && data[3] === 0x46 &&
        data[8] === 0x57 && data[9] === 0x45 && data[10] === 0x42 && data[11] === 0x50) {
      return '.webp';
    }
    if (data.length > 5 && data[0] === 0x47 && data[1] === 0x49 && data[2] === 0x46) {
      return '.gif';
    }
    if (data.length > 3 && data[0] === 0x4D && data[1] === 0x4F && data[2] === 0x43 && data[3] === 0x33) {
      return '.moc3';
    }
    if (data.length > 2 && data[0] === 0x49 && data[1] === 0x44 && data[2] === 0x33) {
      return '.moc';
    }
    if (data.length > 3 && data[0] === 0xFF && data[1] === 0xFB) {
      return '.mp3';
    }
    if (data.length > 11 && data[0] === 0x52 && data[1] === 0x49 && data[2] === 0x46 && data[3] === 0x46 &&
        !(data[8] === 0x57 && data[9] === 0x45 && data[10] === 0x42 && data[11] === 0x50)) {
      return '.wav';
    }
    try {
      const text = new TextDecoder('utf-8').decode(data);
      JSON.parse(text);
      return '.json';
    } catch (e) {
      return '';
    }
  }

  function getRelativePath(filename) {
    const fileExt = filename.toLowerCase().substring(filename.lastIndexOf('.'));
    const filenameLower = filename.toLowerCase();
    
    if (['.png', '.jpg', '.jpeg', '.webp', '.gif', '.bmp', '.tga'].indexOf(fileExt) !== -1) {
      return 'textures/' + filename;
    } else if (filenameLower.indexOf('motion') !== -1 && fileExt === '.json') {
      if (filenameLower.indexOf('idle') !== -1) {
        return ('motions/idle/' + filename).replace('.json', '.motion3.json');
      } else if (filenameLower.indexOf('tap') !== -1 || filenameLower.indexOf('touch') !== -1) {
        return ('motions/tap/' + filename).replace('.json', '.motion3.json');
      } else if (filenameLower.indexOf('flick') !== -1) {
        return ('motions/flick/' + filename).replace('.json', '.motion3.json');
      } else if (filenameLower.indexOf('pinch') !== -1) {
        return ('motions/pinch/' + filename).replace('.json', '.motion3.json');
      } else {
        return ('motions/' + filename).replace('.json', '.motion3.json');
      }
    } else if ((filenameLower.indexOf('expression') !== -1 || filenameLower.indexOf('exp') !== -1) && fileExt === '.json') {
      return ('expressions/' + filename).replace('.json', '.exp3.json');
    } else if (filenameLower.indexOf('physics') !== -1 && fileExt === '.json') {
      return ('physics/' + filename).replace('.json', '.physic3.json');
    } else if (filenameLower.indexOf('pose') !== -1 && fileExt === '.json') {
      return ('pose/' + filename).replace('.json', '.pose.json');
    } else if (filenameLower.indexOf('effect') !== -1 && fileExt === '.json') {
      return 'effects/' + filename;
    } else if (filenameLower.indexOf('userdata') !== -1 && fileExt === '.json') {
      return 'userdata/' + filename;
    } else if (['.wav', '.mp3', '.ogg'].indexOf(fileExt) !== -1) {
      return 'sounds/' + filename;
    } else if (fileExt === '.moc3' || filenameLower.endsWith('.model3.json')) {
      return filename;
    } else {
      return filename;
    }
  }

  function getDecryptKey(mlveConfig, filename, config) {
    if (mlveConfig.type === 'STM_1_0' && mlveConfig.encrypt === 'true') {
      if (!config || !config.fileId || !config.metaData) {
        throw new Error('Steam Workshop LPK需要config.json文件进行解密');
      }
      return genkey(mlveConfig.id + config.fileId + filename + config.metaData);
    } else if (mlveConfig.type === 'STD2_0') {
      return genkey(mlveConfig.id + filename);
    } else {
      return 0n;
    }
  }

  function arrayBufferToBase64(buffer) {
    let binary = '';
    const bytes = new Uint8Array(buffer);
    const len = bytes.byteLength;
    for (let i = 0; i < len; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return window.btoa(binary);
  }

  function getMimeType(filename) {
    const ext = filename.split('.').pop().toLowerCase();
    const mimeTypes = {
      'png': 'image/png',
      'jpg': 'image/jpeg',
      'jpeg': 'image/jpeg',
      'webp': 'image/webp',
      'gif': 'image/gif',
      'bmp': 'image/bmp',
      'tga': 'image/x-tga',
      'json': 'application/json',
      'moc3': 'application/octet-stream',
      'motion3.json': 'application/json',
      'physic3.json': 'application/json',
      'exp3.json': 'application/json',
      'pose.json': 'application/json',
      'mp3': 'audio/mpeg',
      'wav': 'audio/wav',
      'ogg': 'audio/ogg'
    };
    return mimeTypes[ext] || 'application/octet-stream';
  }

  // 实际的 JSZip 加载
  // 主类
  class Live2DWidget {
    constructor(options) {
      options = options || {};
      this.options = {
        lpkFile: options.lpkFile || '/model.lpk',
        configFile: options.configFile || null,
        manualConfig: options.manualConfig || {},
        width: options.width || 300,
        height: options.height || 400,
        position: options.position || 'right',
        bottom: options.bottom !== undefined ? options.bottom : 0,
        right: options.right !== undefined ? options.right : 0,
        left: options.left || 'auto',
        // 默认统一使用 scale，如需响应式可设置 mobileScale
        scale: options.scale || 0.15,
        mobileScale: options.mobileScale || null,
        // 移动端专属配置（默认与桌面端一致）
        mobileWidth: options.mobileWidth || null,
        mobileHeight: options.mobileHeight || null,
        mobilePosition: options.mobilePosition || null,
        mobileBottom: options.mobileBottom || null,
        // 模型在画布中的位置（默认居中，x: 0.5, y: 0.5 表示中心）
        modelX: options.modelX !== undefined ? options.modelX : 0.5,
        modelY: options.modelY !== undefined ? options.modelY : 0.5,
        modelYOffset: options.modelYOffset !== undefined ? options.modelYOffset : 50,
        // 移动端模型位置（可选）
        mobileModelX: options.mobileModelX || null,
        mobileModelY: options.mobileModelY || null,
        mobileModelYOffset: options.mobileModelYOffset || null,
        draggable: options.draggable !== false,
        clickable: options.clickable !== false,
        // 点击动作映射，默认使用模型自带的 hit 区域映射到同名动作组
        hitAreaMapping: options.hitAreaMapping || null,
        // 是否播放动作音效（默认 false）
        soundEnabled: options.soundEnabled === true,
        // 是否点击时播放动作（默认 true）
        tapMotion: options.tapMotion !== false,
        // 是否忽略 hit 区域映射，随机播放动作
        randomMotion: options.randomMotion === true,
        // 要删除的动作组名称列表（默认空数组，不删除任何动作）
        excludeMotions: options.excludeMotions || [],
        // 初始循环播放的动作组名称（默认 null，不循环播放）
        idleMotion: options.idleMotion || null,
        // 自定义第三方 JS 库 URL
        libUrls: options.libUrls || {}
      };
      
      this.container = null;
      this.canvas = null;
      this.app = null;
      this.model = null;
      this.fileDataUrls = {};
      this.extractedFiles = {};
      this.motionGroups = {};
      this.isLoopingRestore = false;
      this.loaded = false;
    }

    async init() {
      await this.createContainer();
      await this.loadDependencies();
      await this.loadModel();
    }

    isMobile() {
      return window.innerWidth < 768;
    }

    getResponsiveOption(desktopKey, mobileKey) {
      var isMobile = this.isMobile();
      var mobileValue = this.options[mobileKey];
      if (isMobile && mobileValue !== null && mobileValue !== undefined) {
        return mobileValue;
      }
      return this.options[desktopKey];
    }

    async createContainer() {
      // 获取响应式配置
      var width = this.getResponsiveOption('width', 'mobileWidth');
      var height = this.getResponsiveOption('height', 'mobileHeight');
      var position = this.getResponsiveOption('position', 'mobilePosition');
      var bottom = this.getResponsiveOption('bottom', 'mobileBottom');

      this.container = document.createElement('div');
      this.container.id = 'live2d-widget-container';
      var cssText = 'position: fixed;';
      if (position === 'left') {
        cssText += ' left: 0; right: auto;';
      } else {
        cssText += ' right: ' + (this.options.right || 0) + 'px; left: auto;';
      }
      cssText += ' bottom: ' + bottom + 'px;';
      cssText += ' width: ' + width + 'px;';
      cssText += ' height: ' + height + 'px;';
      cssText += ' z-index: 99999;';
      cssText += ' pointer-events: none;';
      cssText += ' user-select: none;';
      cssText += ' -webkit-user-select: none;';
      this.container.style.cssText = cssText;

      this.canvas = document.createElement('canvas');
      this.canvas.id = 'live2d-widget-canvas';
      this.canvas.width = width;
      this.canvas.height = height;
      this.canvas.style.cssText = 'width: 100%; height: 100%; pointer-events: auto; display: block;';

      this.container.appendChild(this.canvas);
      document.body.appendChild(this.container);
    }

    async loadDependencies() {
      var libUrls = this.options.libUrls || {};
      var scripts = [
        libUrls.cubismCore || 'https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js',
        libUrls.live2d || 'https://cdn.jsdelivr.net/gh/dylanNew/live2d/webgl/Live2D/lib/live2d.min.js',
        libUrls.pixi || 'https://cdn.jsdelivr.net/npm/pixi.js@7.3.2/dist/pixi.min.js',
        libUrls.pixiLive2d || 'https://cdn.jsdelivr.net/npm/pixi-live2d-display@0.4.0/dist/index.min.js'
      ];

      for (var i = 0; i < scripts.length; i++) {
        if (!document.querySelector('script[src="' + scripts[i] + '"]')) {
          await loadScript(scripts[i]);
        }
      }
    }

    async loadRealJSZip() {
      if (window.JSZip) return window.JSZip;
      var libUrls = this.options.libUrls || {};
      var jszipUrl = libUrls.jszip || 'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js';
      await loadScript(jszipUrl);
      return window.JSZip;
    }

    async loadModel() {
      try {
        var response = await fetch(this.options.lpkFile);
        if (!response.ok) {
          throw new Error('无法加载 LPK 文件: ' + this.options.lpkFile);
        }
        var arrayBuffer = await response.arrayBuffer();
        var lpkFile = new File([arrayBuffer], this.options.lpkFile.split('/').pop(), { type: 'application/zip' });

        var config = null;
        if (Object.keys(this.options.manualConfig).length > 0) {
          config = this.options.manualConfig;
        } else if (this.options.configFile) {
          try {
            var configResponse = await fetch(this.options.configFile);
            if (configResponse.ok) {
              config = await configResponse.json();
            }
          } catch (e) {
            console.log('未找到 config.json，将尝试无配置模式加载');
          }
        }

        var JSZipLib = await this.loadRealJSZip();
        var result = await this.unpackLPK(lpkFile, config, JSZipLib);
        this.extractedFiles = result.files;

        this.fileDataUrls = {};
        for (var filename in this.extractedFiles) {
          if (this.extractedFiles.hasOwnProperty(filename)) {
            var mimeType = getMimeType(filename);
            var base64 = arrayBufferToBase64(this.extractedFiles[filename]);
            this.fileDataUrls[filename] = 'data:' + mimeType + ';base64,' + base64;
          }
        }

        this.setupInterceptors();
        await this.initPixi(result.modelFileName);

      } catch (error) {
        console.error('Live2D 加载失败:', error);
        this.showError(error.message);
      }
    }

    async unpackLPK(file, config, JSZipLib) {
      var zip = await JSZipLib.loadAsync(file);
      var configHash = md5String('config.mlve');
      
      var mlveConfigRaw = null;
      for (var name in zip.files) {
        if (name === configHash) {
          mlveConfigRaw = await zip.file(name).async('string');
          break;
        }
      }
      
      if (!mlveConfigRaw) {
        throw new Error('未找到 config.mlve 文件');
      }
      
      var mlveConfig = JSON.parse(mlveConfigRaw);
      var entrys = {};
      var trans = {};
      var extractedFiles = {};
      
      for (var c = 0; c < mlveConfig.list.length; c++) {
        var chara = mlveConfig.list[c];
        for (var co = 0; co < chara.costume.length; co++) {
          var costume = chara.costume[co];
          if (costume.path === '') continue;
          await this.extractModelJson(zip, costume.path, mlveConfig, config, entrys, trans, extractedFiles);
        }
      }
      
      for (var n in entrys) {
        if (entrys.hasOwnProperty(n)) {
          var outS = entrys[n];
          for (var k in trans) {
            if (trans.hasOwnProperty(k)) {
              outS = outS.replace(new RegExp(k.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), trans[k]);
            }
          }
          extractedFiles[n] = new TextEncoder().encode(outS);
        }
      }
      
      var keys = Object.keys(entrys);
      return {
        files: extractedFiles,
        modelFileName: keys[0]
      };
    }

    async extractModelJson(zip, modelJson, mlveConfig, config, entrys, trans, extractedFiles) {
      if (trans[modelJson]) return;
      
      var data = await zip.file(modelJson).async('uint8array');
      var key = getDecryptKey(mlveConfig, modelJson, config);
      var decrypted = decrypt(key, data);
      
      try {
        var entryS = new TextDecoder('utf-8').decode(decrypted);
        var entry = JSON.parse(entryS);
        
        if (entry.FileReferences && entry.FileReferences.PhysicsV2) {
          delete entry.FileReferences.PhysicsV2;
        }
        
        var id = Object.keys(entrys).length;
        var modelName = 'model' + id + '.model3.json';
        entrys[modelName] = JSON.stringify(entry);
        trans[modelJson] = modelName;
        
        for (var item of travelsDict(entry)) {
          var name = item[0];
          var val = item[1];
          
          if ((name.toLowerCase().endsWith('_command') || name.toLowerCase().endsWith('_postcommand')) && val) {
            var commands = val.split(';');
            for (var cmd of commands) {
              var encFile = findEncryptedFile(cmd);
              if (!encFile) continue;
              
              if (cmd.startsWith('change_cos')) {
                await this.extractModelJson(zip, encFile, mlveConfig, config, entrys, trans, extractedFiles);
              } else {
                var newName = name + '_' + id;
                var result = await this.recoveryFile(zip, encFile, mlveConfig, config, newName, extractedFiles);
                trans[encFile] = result[0];
              }
            }
          }
          
          if (isEncryptedFile(val)) {
            if (trans[val]) continue;
            var newName2 = name + '_' + id;
            var result2 = await this.recoveryFile(zip, val, mlveConfig, config, newName2, extractedFiles);
            trans[val] = result2[0];
          }
        }
      } catch (e) {
        throw e;
      }
    }

    async recoveryFile(zip, filename, mlveConfig, config, outputName, extractedFiles) {
      var data = await zip.file(filename).async('uint8array');
      var key = getDecryptKey(mlveConfig, filename, config);
      var ret = decrypt(key, data);
      var suffix = guessType(ret);
      var baseName = outputName + suffix;
      var savedPath = getRelativePath(baseName);
      extractedFiles[savedPath] = ret;
      return [savedPath, suffix];
    }

    setupInterceptors() {
      var self = this;
      
      var originalFetch = window.fetch;
      window.fetch = function(url, options) {
        var urlStr = typeof url === 'string' ? url : url.toString();
        var urlBaseName = urlStr.split('/').pop().toLowerCase();
        
        for (var filename in self.fileDataUrls) {
          if (self.fileDataUrls.hasOwnProperty(filename)) {
            var fileBaseName = filename.split('/').pop().toLowerCase();
            if (urlStr.indexOf(filename) !== -1 || urlBaseName === fileBaseName) {
              return fetch(self.fileDataUrls[filename]);
            }
          }
        }
        return originalFetch.apply(this, arguments);
      };
      
      var OriginalXHR = window.XMLHttpRequest;
      window.XMLHttpRequest = function() {
        var xhr = new OriginalXHR();
        var originalOpen = xhr.open;
        var originalSend = xhr.send;
        
        var _url = '';
        var _responseType = '';
        
        xhr.open = function(method, url) {
          _url = url;
          return originalOpen.apply(this, arguments);
        };
        
        Object.defineProperty(xhr, 'responseType', {
          get: function() { return _responseType; },
          set: function(value) { _responseType = value; },
          configurable: true
        });
        
        xhr.send = function() {
          var urlBaseName = _url ? _url.split('/').pop() : '';
          for (var filename in self.fileDataUrls) {
            if (self.fileDataUrls.hasOwnProperty(filename)) {
              var fileBaseName = filename.split('/').pop();
              if (_url && (_url.indexOf(filename) !== -1 || urlBaseName === fileBaseName)) {
                var dataUrl = self.fileDataUrls[filename];
                if (dataUrl.startsWith('data:')) {
                  var base64 = dataUrl.split(',')[1];
                  var binary = window.atob(base64);
                  var bytes = new Uint8Array(binary.length);
                  for (var i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                  }
                  
                  setTimeout(function() {
                    Object.defineProperty(xhr, 'readyState', { value: 4, writable: true });
                    Object.defineProperty(xhr, 'status', { value: 200, writable: true });
                    Object.defineProperty(xhr, 'statusText', { value: 'OK', writable: true });
                    Object.defineProperty(xhr, 'responseURL', { value: _url, writable: true });
                    
                    if (filename.endsWith('.json') || _responseType === 'json') {
                      var text = new TextDecoder('utf-8').decode(bytes);
                      Object.defineProperty(xhr, 'responseText', { value: text, writable: true });
                      try {
                        var jsonObj = JSON.parse(text);
                        Object.defineProperty(xhr, 'response', { value: jsonObj, writable: true });
                      } catch (e) {
                        Object.defineProperty(xhr, 'response', { value: text, writable: true });
                      }
                    } else if (_responseType === 'arraybuffer') {
                      Object.defineProperty(xhr, 'response', { value: bytes.buffer, writable: true });
                    } else if (_responseType === 'blob') {
                      var blob = new Blob([bytes]);
                      Object.defineProperty(xhr, 'response', { value: blob, writable: true });
                    } else {
                      Object.defineProperty(xhr, 'response', { value: bytes.buffer, writable: true });
                    }
                    
                    xhr.readyState = 4;
                    
                    var readystatechangeEvent = new Event('readystatechange');
                    xhr.dispatchEvent(readystatechangeEvent);
                    
                    var loadEvent = new Event('load');
                    xhr.dispatchEvent(loadEvent);
                    
                    if (xhr.onload) xhr.onload(loadEvent);
                    if (xhr.onreadystatechange) xhr.onreadystatechange(readystatechangeEvent);
                  }, 0);
                  return;
                }
              }
            }
          }
          return originalSend.apply(this, arguments);
        };
        
        return xhr;
      };
    }

    async initPixi(modelFileName) {
      var modelJsonData = this.extractedFiles[modelFileName];
      var modelJsonText = new TextDecoder('utf-8').decode(modelJsonData);
      var modelJson = JSON.parse(modelJsonText);
      
      var self = this;
      var replacePaths = function(obj) {
        if (typeof obj === 'string') {
          var imageExts = ['.png', '.jpg', '.jpeg', '.webp', '.gif', '.bmp', '.tga'];
          var isImage = false;
          for (var ext of imageExts) {
            if (obj.toLowerCase().endsWith(ext)) {
              isImage = true;
              break;
            }
          }
          if (isImage) {
            var objBaseName = obj.split('/').pop().toLowerCase();
            for (var filename in self.fileDataUrls) {
              if (self.fileDataUrls.hasOwnProperty(filename)) {
                var fileBaseName = filename.split('/').pop().toLowerCase();
                if (obj === filename || obj.endsWith('/' + filename) || objBaseName === fileBaseName) {
                  return self.fileDataUrls[filename];
                }
              }
            }
          }
          return obj;
        } else if (Array.isArray(obj)) {
          return obj.map(function(item) { return replacePaths(item); });
        } else if (typeof obj === 'object' && obj !== null) {
          var result = {};
          for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
              result[key] = replacePaths(obj[key]);
            }
          }
          return result;
        }
        return obj;
      };
      
      modelJson = replacePaths(modelJson);
      modelJson.url = 'data:application/json;base64,eyJtb2RlbCI6InRlc3QifQ==';
      
      // 根据配置删除指定的动作组
      if (modelJson.FileReferences && modelJson.FileReferences.Motions) {
        var excludeMotions = this.options.excludeMotions || [];
        for (var i = 0; i < excludeMotions.length; i++) {
          var motionName = excludeMotions[i];
          if (modelJson.FileReferences.Motions[motionName]) {
            delete modelJson.FileReferences.Motions[motionName];
          }
        }
      }

      // 获取响应式尺寸
      var appWidth = this.getResponsiveOption('width', 'mobileWidth');
      var appHeight = this.getResponsiveOption('height', 'mobileHeight');

      this.app = new PIXI.Application({
        view: this.canvas,
        width: appWidth,
        height: appHeight,
        backgroundAlpha: 0,
        resolution: window.devicePixelRatio || 1,
        autoDensity: true,
        antialias: true
      });

      var Live2DModel = window.PIXI.live2d ? window.PIXI.live2d.Live2DModel : window.Live2DModel;
      this.model = await Live2DModel.from(modelJson);
      this.app.stage.addChild(this.model);

      // 如果设置了 mobileScale 且是移动端，则使用 mobileScale，否则统一使用 scale
      var scale = this.options.mobileScale && this.isMobile() ? this.options.mobileScale : this.options.scale;
      
      // 获取模型位置配置（支持响应式）
      var modelX = this.getResponsiveOption('modelX', 'mobileModelX');
      var modelY = this.getResponsiveOption('modelY', 'mobileModelY');
      var modelYOffset = this.getResponsiveOption('modelYOffset', 'mobileModelYOffset');
      
      this.model.anchor.set(0.5, 0.5);
      this.model.x = appWidth * modelX;
      this.model.y = appHeight * modelY + modelYOffset;
      this.model.scale.set(scale);

      this.collectMotions(modelJson);

      if (this.options.clickable) {
        this.setupInteraction();
      }

      // 设置鼠标跟随
      this.setupMouseTracking();

      this.startRestoreLoop();
      this.loaded = true;
    }

    collectMotions(modelJson) {
      this.motionGroups = {};
      if (modelJson.FileReferences && modelJson.FileReferences.Motions) {
        this.motionGroups = modelJson.FileReferences.Motions;
        // 已经在上一步删除了 excludeMotions 中的动作，这里不需要再删除
      }
    }

    setupInteraction() {
      if (!this.model) return;
      
      var self = this;
      var isDragging = false;
      var dragStartX = 0;
      var dragStartY = 0;
      var modelStartX = 0;
      var modelStartY = 0;
      var hasMoved = false;
      
      this.model.eventMode = 'static';
      this.model.cursor = 'pointer';
      
      this.app.stage.eventMode = 'static';
      this.app.stage.hitArea = new PIXI.Rectangle(0, 0, this.app.screen.width, this.app.screen.height);
      
      this.model.on('pointerdown', function(event) {
        if (!self.options.draggable) return;
        isDragging = true;
        hasMoved = false;
        dragStartX = event.data.global.x;
        dragStartY = event.data.global.y;
        modelStartX = self.container.offsetLeft;
        modelStartY = self.container.offsetTop;
      });
      
      this.model.on('pointermove', function(event) {
        if (!isDragging || !self.options.draggable) return;
        var dx = event.data.global.x - dragStartX;
        var dy = event.data.global.y - dragStartY;
        
        if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
          hasMoved = true;
        }
        
        self.container.style.left = (modelStartX + dx) + 'px';
        self.container.style.top = (modelStartY + dy) + 'px';
      });
      
      this.model.on('pointerup', function() {
        isDragging = false;
      });
      
      this.model.on('pointerupoutside', function() {
        isDragging = false;
      });
      
      this.model.on('hit', function(hitAreas) {
        if (isDragging || hasMoved) return;
        
        // 如果禁用了点击播放动作，直接返回
        if (!self.options.tapMotion) {
          return;
        }
        
        self.isLoopingRestore = false;
        
        // 如果启用随机播放，忽略 hit 区域映射
        if (self.options.randomMotion) {
          var idleMotion = self.options.idleMotion;
          var motionGroupNames = Object.keys(self.motionGroups).filter(function(name) {
            return name !== idleMotion && self.motionGroups[name].length > 0;
          });
          
          if (motionGroupNames.length > 0) {
            var randomGroupIndex = Math.floor(Math.random() * motionGroupNames.length);
            var randomGroup = motionGroupNames[randomGroupIndex];
            var randomIndex = Math.floor(Math.random() * self.motionGroups[randomGroup].length);
            console.log('随机播放:', randomGroup, '索引:', randomIndex);
            self.playMotion(randomGroup, randomIndex);
          }
          return;
        }
        
        // 使用用户配置的映射，如果没有则使用 hit 区域名直接映射到同名动作组
        var hitAreaMapping = self.options.hitAreaMapping || {};
        
        console.log('点击区域:', hitAreas);
        
        for (var hitArea of hitAreas) {
          // 优先使用用户配置的映射，否则使用 hit 区域名本身
          var targetGroup = hitAreaMapping[hitArea] || hitArea;
          
          if (self.motionGroups[targetGroup]) {
            var group = self.motionGroups[targetGroup];
            if (group.length > 0) {
              var randomIndex = Math.floor(Math.random() * group.length);
              console.log('播放动作:', targetGroup, '索引:', randomIndex);
              self.playMotion(targetGroup, randomIndex);
              return;
            }
          }
        }
        
        // 如果没有匹配到任何动作，尝试播放第一个可用的动作组
        var idleMotion = self.options.idleMotion;
        var motionGroupNames = Object.keys(self.motionGroups);
        for (var groupName of motionGroupNames) {
          if (groupName !== idleMotion && self.motionGroups[groupName].length > 0) {
            var randomIndex = Math.floor(Math.random() * self.motionGroups[groupName].length);
            console.log('默认播放:', groupName, '索引:', randomIndex);
            self.playMotion(groupName, randomIndex);
            return;
          }
        }
      });
    }

    playMotion(groupName, index) {
      if (!this.model || !this.motionGroups[groupName]) return;

      var group = this.motionGroups[groupName];
      if (!group || !group[index]) return;

      var motion = group[index];

      try {
        this.model.motion(groupName, index);
      } catch (e) {
        console.error('播放动作失败:', e);
        return;
      }

      // 只有在启用音效时才播放音频
      if (motion.Sound && this.options.soundEnabled) {
        var audioUrl = motion.Sound;
        for (var filename in this.fileDataUrls) {
          if (this.fileDataUrls.hasOwnProperty(filename)) {
            if (motion.Sound.endsWith(filename) || filename.endsWith(motion.Sound.split('/').pop())) {
              audioUrl = this.fileDataUrls[filename];
              break;
            }
          }
        }

        var audio = new Audio(audioUrl);
        audio.play().catch(function(e) {
          console.log('音频播放失败:', e);
        });
      }
    }

    setupMouseTracking() {
      if (!this.model) return;
      
      var self = this;
      var canvas = this.canvas;
      
      // 监听鼠标移动
      document.addEventListener('mousemove', function(e) {
        if (!self.model || !self.model.internalModel) return;
        
        // 获取画布在屏幕上的位置
        var rect = canvas.getBoundingClientRect();
        
        // 计算鼠标相对于画布中心的位置
        var centerX = rect.left + rect.width / 2;
        var centerY = rect.top + rect.height / 2;
        
        // 归一化到 -1 到 1 的范围
        var mouseX = (e.clientX - centerX) / (rect.width / 2);
        var mouseY = (e.clientY - centerY) / (rect.height / 2);
        
        // 限制范围
        mouseX = Math.max(-1, Math.min(1, mouseX));
        mouseY = Math.max(-1, Math.min(1, mouseY));
        
        // Y轴取反（屏幕坐标系和Live2D坐标系相反）
        mouseY = -mouseY;
        
        // 设置模型朝向
        self.model.internalModel.focusController.focus(mouseX, mouseY);
      });
      
      // 触摸设备支持
      document.addEventListener('touchmove', function(e) {
        if (!self.model || !self.model.internalModel) return;
        
        var touch = e.touches[0];
        var rect = canvas.getBoundingClientRect();
        
        var centerX = rect.left + rect.width / 2;
        var centerY = rect.top + rect.height / 2;
        
        var mouseX = (touch.clientX - centerX) / (rect.width / 2);
        var mouseY = (touch.clientY - centerY) / (rect.height / 2);
        
        mouseX = Math.max(-1, Math.min(1, mouseX));
        mouseY = Math.max(-1, Math.min(1, mouseY));
        
        // Y轴取反
        mouseY = -mouseY;
        
        self.model.internalModel.focusController.focus(mouseX, mouseY);
      });
    }

    startRestoreLoop() {
      var self = this;
      var idleMotion = self.options.idleMotion;
      
      // 如果没有配置初始循环动作，直接返回
      if (!idleMotion) {
        return;
      }
      
      if (this.model.internalModel && this.model.internalModel.motionManager) {
        this.model.internalModel.motionManager.stopAllMotions();
      }
      
      setTimeout(function() {
        if (self.model.internalModel && self.model.internalModel.motionManager) {
          self.model.internalModel.motionManager.stopAllMotions();
        }
        
        // 使用配置的初始循环动作组
        if (self.motionGroups[idleMotion] && self.motionGroups[idleMotion].length > 0) {
          self.isLoopingRestore = true;
          self.model.motion(idleMotion, 0);
          self.model.on('motion', function() {
            if (self.isLoopingRestore) {
              self.model.motion(idleMotion, 0);
            }
          });
        }
      }, 100);
    }

    showError(message) {
      console.error('Live2D Widget Error:', message);
      if (this.container) {
        this.container.innerHTML = '<div style="color: red; padding: 20px; text-align: center;">加载失败: ' + message + '</div>';
      }
    }

    destroy() {
      if (this.app) {
        this.app.destroy(true);
      }
      if (this.container && this.container.parentNode) {
        this.container.parentNode.removeChild(this.container);
      }
    }
  }

  // 全局 API
  global.Live2DWidget = {
    init: async function(options) {
      var widget = new Live2DWidget(options);
      await widget.init();
      return widget;
    },
    
    quickInit: function(lpkFile, options) {
      options = options || {};
      options.lpkFile = lpkFile;
      return this.init(options);
    }
  };

})(window);
